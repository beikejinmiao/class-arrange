#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define DATA_LINE_LENGTH    25

#define INIT_NUMBER -1
#define CLASS_ARRANGED      1
#define CLASS_NOT_ARRANGED  0
#define BIG_CLASS_NUM_MAX   30


#define allocate_space() ((scls *)malloc(sizeof(scls)))


typedef struct SmallCls{
    int id;
    int pid;
    int priority;
    int student_num;
    int is_arranged;
    int x;  //id of lab
    int y;  //id of time
}scls;

typedef struct node{
    scls *data;
    struct node *next;
}scls_node, *scls_list;


int resolve_row(char *row, scls *cls);
int string2int(char *str);
scls_list init_scls_list(scls *head_data);
void insert_scls(scls_list head, scls *data);
void arrange_handle(scls_list bcls_arr, int bcls_num);
void backtrace(scls_list head);
scls_list new_sequence(scls_list head);


const int TimeLab[4][5] = 
{
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60}
};

int currw = 0;      //当前人数
int bestw = 0;      //最优人数
int restw = 0;      //剩余人数

int cuur_totalw = 0;    //当前实验室总容量

int main(){
    int i = 0;
    int bcls_count = 0;
    FILE *fp;
    char ch, str[DATA_LINE_LENGTH];
    int bcls_id_old = INIT_NUMBER;
    int bcls_id_new = INIT_NUMBER;
    
    scls *small_class;
    scls_list big_class_arr[BIG_CLASS_NUM_MAX];
    scls_list scls_list_head, p;

    if((fp=fopen("./small_class_info.txt", "rt")) == NULL){
        printf("\nCan't open file!");
        exit(1);
    }  

    i = 0; 
    while(fgets(str, DATA_LINE_LENGTH, fp) != NULL){
        small_class = allocate_space();
        bcls_id_new = resolve_row(str, small_class);
        if(bcls_id_new != bcls_id_old){
            bcls_count++;
            scls_list_head = init_scls_list(small_class);
            big_class_arr[i++] = scls_list_head;
            bcls_id_old = bcls_id_new;
        }else{
            insert_scls(scls_list_head, small_class);
        }
    }
    arrange_handle(big_class_arr, bcls_count);
    //for(i=0; i<bcls_count; i++){
    //    scls_list_head = big_class_arr[i];
    //    p = scls_list_head;
    //    while(p != NULL){
    //        printf("id:%d, pid:%d, priority:%d, num:%d, is_arranged:%d\n", 
    //                p->data->id,p->data->pid,p->data->priority,p->data->student_num,p->data->is_arranged);

    //        p = p->next;
    //    }

    //    printf("*****************\n");
    //}


    fclose(fp);

    return 0;
}

scls_list init_scls_list(scls *head_data){
    scls_list list;
    list = (scls_list)malloc(sizeof(scls_node));
    list->data = head_data;
    list->next = NULL;
    return list;
}

void insert_scls(scls_list head, scls *data){
    int i = 0; 
    scls_list new_tail;
    scls_list p = head;

    new_tail = (scls_list)malloc(sizeof(scls_node));
    new_tail->data = data;
    new_tail->next = NULL;
    while(p->next != NULL){
        p = p->next;
    }
    p->next = new_tail;
    //return new_tail;
}



int resolve_row(char *row, scls *cls){
    int len = strlen(row);
    int i, tmp;
    int big_class_id = INIT_NUMBER;
    char *val;
    const char *split = "\t";
    
    row[len-2] = '\0';  //windows newline is '\r\n'
    val = strtok(row, split);
    i = 0;
    while(val != NULL){
        tmp = string2int(val);
        switch(i){
            case 0: cls->id = tmp; break;
            case 1: {
                        cls->pid = tmp; 
                        big_class_id = tmp;
                        break;
                    }
            case 2: cls->priority = tmp; break;
            case 3: cls->student_num = tmp; break;
            case 4: cls->is_arranged = tmp; break;
        }
        i++;
        val = strtok(NULL, split);
    }
    cls->x = INIT_NUMBER;
    cls->y = INIT_NUMBER;

    return big_class_id;
}

int string2int(char *str){
    int len = strlen(str);
    int i;
    int decimal = 1;
    int sum = 0;
    for(i=len-1; i>=0; i--){
        decimal *= 10;
        sum += (str[i]-'0') * decimal; 
    }
    sum = sum / 10;
    return sum;
}


void arrange_handle(scls_list bcls_arr, int bcls_num){
    int i, j;
    int k = 0;
    int flag_arrange_new_bcls = 1;

    scls_list head, p, q;
    scls_list new_head = NULL;
    for(i=0; i<4; i++){
        for(j=0; j<5; j++){
           if(new_head == NULL){
               new_head = bcls_arr[k];
               k++;
               //这样设计还是会有问题
               //如：新的班级还是未能填满剩余的空位
               if(restw > 0){
                   curr_totalw = restw;
                   backtrace(new_head);
                   new_head = new_sequence(head);
                   p = new_head;
                   while(p != NULL){
                       if(p->is_arranged == CLASS_ARRANGED){
                           p->x = i;
                           p->y = j;
                       }
                       p = p->next;
                   }
               }
           }

           curr_totalw = TimaLab[i][j];
           backtrace(new_head);
           new_head = new_sequence(head);
           p = new_head;
           while(p != NULL){
               if(p->is_arranged == CLASS_ARRANGED){
                   p->x = i;
                   p->y = j;
               }
               p = p->next;
           }
 
        }
    }
}


//回溯排课
void backtrace(scls_list head){
    int i;
    scls_list p = head;
    //到达叶子节点
    if(p == NULL){
        if(currw > bestw){
            bestw = currw;
        }
        return;
    }
    
    restw -= p->student_num;
    //搜索左子树
    if(currw + p->student_num < curr_totalw){
        p->is_arranged = CLASS_ARRANGED;
        currw += p->student_num;
        backtrace(p->next);
        currw -= p->student_num;
    }
    //搜索右子树
    if(currw + restw > bestw){
        p->is_arranged = CLASS_NOT_ARRANGED;
        backtrace(p->next);
    }
    restw += p->student_num;
}

//重新将小班排序
//将已排课的小班排在链表头，未排课的下班放在链表尾
scls_list new_sequence(scls_list head){

}







