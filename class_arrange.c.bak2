#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define INIT_NUMBER         -1
#define RETURN_CODE_SUCCESS 0
#define RETURN_CODE_NULL    -1

#define DATA_LINE_LENGTH    25
#define BIG_CLASS_NUM_MAX   30

#define CLASS_ARRANGED              1
#define CLASS_NOT_ARRANGED          0
#define FLAG_LIST_ALL_ARRANGED      1
#define FLAG_LIST_ALL_NOT_ARRANGED  0

#define allocate_space() ((scls *)malloc(sizeof(scls)))


typedef struct SmallCls{
    int id;
    int pid;
    int priority;
    int student_num;
    int is_arranged;
    int x;  //id of lab
    int y;  //id of time
}scls;

typedef struct node{
    scls *data;
    struct node *next;
}scls_node, *scls_list;


int resolve_row(char *row, scls *cls);
int string2int(char *str);
scls_list init_scls_list(scls *head_data);
void insert_scls(scls_list head, scls *data);
void arrange_handle(scls_list *bcls_arr);
void backtrace(scls_list head);
scls_list renew_list_sequence(scls_list head);
int set_time_lab(scls_list head, int i, int j);
int swap_node_content(scls_list p, scls_list q);
int find_min_num(scls_list head);
void print_list_info(scls_list head);

const int TimeLab[4][5] = 
{
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60},
    {113, 99, 99, 99, 60}
};

int currw = 0;      //实验室当前人数
int bestw = 0;      //实验室最优人数

int restw       = 0;        //实验室剩余容量
int curr_totalw = 0;        //当前实验室总容量

int flag_all_isarranged = FLAG_LIST_ALL_NOT_ARRANGED;

int bcls_num = INIT_NUMBER;

int main(){
    int i = 0;
    FILE *fp;
    char ch, str[DATA_LINE_LENGTH];
    int bcls_id_old = INIT_NUMBER;
    int bcls_id_new = INIT_NUMBER;

    scls *small_class;
    scls_list big_class_arr[BIG_CLASS_NUM_MAX];
    scls_list scls_list_head, p;

    if((fp=fopen("./small_class_info.txt", "rt")) == NULL){
        printf("\nCan't open file!");
        exit(1);
    }  

    i = 0; 
    while(fgets(str, DATA_LINE_LENGTH, fp) != NULL){
        small_class = allocate_space();
        bcls_id_new = resolve_row(str, small_class);
        if(bcls_id_new != bcls_id_old){
            bcls_num++;
            scls_list_head = init_scls_list(small_class);
            big_class_arr[i++] = scls_list_head;
            bcls_id_old = bcls_id_new;
        }else{
            insert_scls(scls_list_head, small_class);
        }
    }
    arrange_handle(big_class_arr);

    for(i=0; i<bcls_num; i++){
        scls_list_head = big_class_arr[i];
        p = scls_list_head;
        while(p != NULL){
            printf("id:%d, pid:%d, priority:%d, num:%d, is_arranged:%d\n", 
                    p->data->id,p->data->pid,p->data->priority,p->data->student_num,p->data->is_arranged);

            p = p->next;
        }
        printf("*****************\n");
    }

    fclose(fp);
    return 0;
}

scls_list init_scls_list(scls *head_data){
    scls_list list;
    list = (scls_list)malloc(sizeof(scls_node));
    list->data = head_data;
    list->next = NULL;
    return list;
}

void insert_scls(scls_list head, scls *data){
    scls_list new_tail;
    scls_list p = head;

    new_tail = (scls_list)malloc(sizeof(scls_node));
    new_tail->data = data;
    new_tail->next = NULL;
    while(p->next != NULL){
        p = p->next;
    }
    p->next = new_tail;
    //return new_tail;
}



int resolve_row(char *row, scls *cls){
    int len = strlen(row);
    int i, tmp;
    int big_class_id = INIT_NUMBER;
    char *val;
    const char *split = "\t";

    row[len-2] = '\0';  //windows newline is '\r\n'
    val = strtok(row, split);
    i = 0;
    while(val != NULL){
        tmp = string2int(val);
        switch(i){
            case 0: cls->id = tmp; break;
            case 1: {
                        cls->pid = tmp; 
                        big_class_id = tmp;
                        break;
                    }
            case 2: cls->priority = tmp; break;
            case 3: cls->student_num = tmp; break;
            case 4: cls->is_arranged = tmp; break;
        }
        i++;
        val = strtok(NULL, split);
    }
    cls->x = INIT_NUMBER;
    cls->y = INIT_NUMBER;

    return big_class_id;
}

int string2int(char *str){
    int len = strlen(str);
    int i;
    int decimal = 1;
    int sum = 0;
    for(i=len-1; i>=0; i--){
        decimal *= 10;
        sum += (str[i]-'0') * decimal; 
    }
    sum = sum / 10;
    return sum;
}


void arrange_handle(scls_list *bcls_arr){
    int i, j;
    int k = 0;
    int min_num = INIT_NUMBER;

    scls_list head = bcls_arr[0];
    scls_list origin_head = head;
    for(i=0; i<4; i++){
        for(j=0; j<5; j++){
            curr_totalw = TimeLab[i][j];
            restw = curr_totalw;
            bestw = INIT_NUMBER;
            currw = INIT_NUMBER;
            if(head != NULL){
                backtrace(head);
                head = renew_list_sequence(head);
            }
            set_time_lab(origin_head, i, j);
            //test
            print_list_info(head);
            
            while(flag_all_isarranged == FLAG_LIST_ALL_ARRANGED){
                k++;
                head = bcls_arr[k];
                origin_head = head;
                flag_all_isarranged = FLAG_LIST_ALL_NOT_ARRANGED;

                min_num =  find_min_num(head);
                if(restw >= min_num){                       //*****************大于最小的班级人数************//
                    curr_totalw = restw;
                    bestw = INIT_NUMBER;
                    currw = INIT_NUMBER;
                    backtrace(head);
                    head = renew_list_sequence(head);
                    set_time_lab(origin_head, i, j);
                }
            }
        }
    }
}


//回溯排课
void backtrace(scls_list head){
    scls_list p = head;
    //到达叶子节点
    if(p == NULL){
        if(currw > bestw){
            bestw = currw;
        }
        return;
    }

    restw -= p->data->student_num;
    //搜索左子树
    if(currw + p->data->student_num < curr_totalw){
        p->data->is_arranged = CLASS_ARRANGED;
        currw += p->data->student_num;
        backtrace(p->next);
        currw -= p->data->student_num;
    }
    //搜索右子树
    if(currw + restw > bestw){
        p->data->is_arranged = CLASS_NOT_ARRANGED;
        backtrace(p->next);
    }
    restw += p->data->student_num;
}

//重新将小班排序
//将已排课的小班排在链表头，未排课的下班放在链表尾
scls_list renew_list_sequence(scls_list head){
    if(head == NULL){
        printf("renew_list_sequence(): new head node of list is null!\n");   
        return NULL; 
    }

    print_list_info(head);              //****************print*****************//

    scls_list new_head = NULL;
    scls_list p = head;
    scls_list q = head;
    while((p != NULL) || (q != NULL)){
        while((p != NULL) && (p->data->is_arranged == CLASS_ARRANGED)){
            p = p->next;
            q = p;
        }
        while((q != NULL) && (q->data->is_arranged == CLASS_NOT_ARRANGED)){
            q = q->next;
        }
        swap_node_content(p,q); 
    }

    new_head = p;
    if(new_head == NULL){
        flag_all_isarranged = FLAG_LIST_ALL_ARRANGED;
    }

    return new_head;
}


int set_time_lab(scls_list head, int i, int j){
    if(head == NULL){
        printf("set_time_lab(): head node of list is null!\n");   
        return RETURN_CODE_NULL; 
    }

    scls_list p = head;
    while(p != NULL){
        if((p->data->is_arranged == CLASS_ARRANGED) && (p->data->x == INIT_NUMBER)){
            p->data->x = i;
            p->data->y = j;
        }
        p = p->next;
    }

    return RETURN_CODE_SUCCESS;
}



int swap_node_content(scls_list p, scls_list q){
    int test;
    
    if(p == NULL || q == NULL){
        printf("swap_node_content(): swap node can not be null!\n");
        return RETURN_CODE_NULL;
    }

    scls_list tmp;
    tmp = (scls_list)malloc(sizeof(scls_node));
    printf("dump\n");
    printf("swap  p_id:%d\n", p->data->id);
    test = p->data->id;
    printf("p:%d\n",test);
    test = tmp->data->id;   //程序在跑出段错误，表明tmp->data->id是不能被访问的。但是在使用gdb调试时，可以看到tmp->data的内容，竟然与p->data一样！！
    printf("tmp:%d\n",test);
    tmp->data->id = 999;
    printf("tmp:%d\n",test);

    tmp->data->id           = p->data->id;
    printf("swap tmp_id:%d, p_id:%d\n",tmp->data->id, p->data->id);

    tmp->data->pid          = p->data->pid;
    printf("swap tmp_id:%d, p_id:%d\n",tmp->data->id, p->data->id);
   
    tmp->data->priority     = p->data->priority;
    tmp->data->student_num  = p->data->student_num;
    tmp->data->is_arranged  = p->data->is_arranged;
    tmp->data->x            = p->data->x;
    tmp->data->y            = p->data->y;

    p->data->id             = q->data->id;
    p->data->pid            = q->data->pid;
    p->data->priority       = q->data->priority;
    p->data->student_num    = q->data->student_num;
    p->data->is_arranged    = q->data->is_arranged;
    p->data->x              = q->data->x;
    p->data->y              = q->data->y;

    q->data->id             = tmp->data->id;
    q->data->pid            = tmp->data->pid;
    q->data->priority       = tmp->data->priority;
    q->data->student_num    = tmp->data->student_num;
    q->data->is_arranged    = tmp->data->is_arranged;
    q->data->x              = tmp->data->x;
    q->data->y              = tmp->data->y;

    free(tmp);
    return RETURN_CODE_SUCCESS;
}


int find_min_num(scls_list head){
    if(head == NULL){
        printf("find_min_num(): head node of list is null!\n");
        return RETURN_CODE_NULL;    
    }

    int min = head->data->student_num;
    scls_list p = head;
    while(p != NULL){
        if(p->data->student_num < min){
            min = p->data->student_num;
        }

        p = p->next;
    }

    return min;
}


void print_list_info(scls_list head){
    scls_list p = head;
    while(p != NULL){
        printf("id:%d, pid:%d, priority:%d, num:%d, is_arranged:%d\n", 
                p->data->id,p->data->pid,p->data->priority,p->data->student_num,p->data->is_arranged);

        p = p->next;
    }
    printf("*****************\n");

}
